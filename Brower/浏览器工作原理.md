# 浏览器工作原理

浏览器将至少有四个进程 分担浏览器中的各各功能的作用 另外 safebrawing 的作用就是检查站点是否安全 确认安全后返回给浏览器端
Dom 树生成过程

1. 在 script 中 没有使用 aynac 或者 defer 属性 会因为加载 js 文件而中断 dom 数的生成 而 css、图片等信息不会导致 dom 的中断
2. 在 dom 树生成后 构建 layout 树 其结合 dom 树与 css 样式生成的 layout 是结合了位置信息
3. dom 树关注的是 html layout 树关注的是 dom 与样式
4. 渲染顺序 以及栅格化概念将信息转为像素并渲染

# tcp/ip 协议与传统七层协议

1. 应用层（会话层、表示层、应用层）
2. tcp 数据传输层 添加端口号
3. ip 网络层 添加 ip 地址
4. 物理层 （物理层、数据链路层）二进制信息转为网络信号

## 猫的概念

是将数字信号翻译成沿着普通电话线传输的模拟信号 并在公共网络上传输 最后到达 ISP NSP
路由表的概念:是包含所有子网内的全部 ip 地址信息 所到达的位置没有 des 的话即向上传递。

# wireshark 工具

来进行抓包处理
mac 网关的作用:

1.  数据包转发，网关作为网络中不同子网之间的桥梁，可以将数据包从一个子网发送到另外一个子网。当源设备要发送数据包到目标设备所在的子网时，它会将数据包发给网关，网关根据目标设备的 IP
    地址判断应该将数据包发送到那个子网。
2.  路由选择: 网关在网络中扮演者路由器的功能，负责根据网络的拓扑结构和路由表选择最佳的路径将数据包转发到目标设备。
3.  网络地址转换（NAT）:网关还可以实现地址转换，将内部私有网络中的 IP 地址转换为公共网络可识别的 IP 地址
4.  访问控制和安全性 网关可以实施访问控制策略，限制进出网络的数据流量。它可以过滤和阻止不符合特定规则的数据包，提供网络安全性和防火墙功能。

#tcp

1. 发送 http 前需要进行三次握手(tcp) 之后确定 ack 再发送 http 请求 接着就是四次挥手
   第一次发送信息 SYN=1 第二次 SYN=1,ACK=1 响应信息 第三次 确认信息 ACK=1
2. 能对数据有一定的控制做作用 即是数据包的顺序
3. 状态码 syn ack
   1. syc 1 发送连接信息 0 确认连接信息
   2. ack 1 是一个确认信息 0 不是一个确认信息
   3. FIN 关闭连接

# 浏览器渲染过程

1. 可以查看 performance 下的内容
   Parse html、 Parse Stylesheet、 recalculate Style、Layout、Updata Layer Tree、 Paint、 Composite Layers
2. 查看网页的层的结构 可以通过 layers
3. 浏览器每次可以接受 64kb

## 重绘与重排

1.  因为浏览器渲染页面的时候是以图层为单位的。 所以这个地方最好将变化的元素作为单独一个图层，将其隔离起来。就不会对其他元素造成影响。
2.  重绘即使元素样式的改变(不包括宽高、大小、位置) 触发重绘的属性 color border-color border-style visibility background background-image background-postion back-repeat outline
    -. 重排

    1. 计算元素在窗口的几何位置 layout
    2. 计算元素在窗口的集体的呈现 paint

       - (要提高性能 即就是减少以上四步) 计算需要被加载到节点上的样式结果、为每个节点生成图形和位置、将每个节点填充到图层中、组合图层到页面上
         1. 元素位置移动变换时使用 css3 中的 transform 来代替 top left （直接使用 transform 会出发重排和重绘）
         2. 配合 posistion:relative 只会触发重绘
         3. 元素作为一个单独的图层处理使用 transform 不会触发重绘、也不会触发重排
       - 使用 opacity 来代替 visibility
         - 使用 visibility 不触发重排，但是依然重绘
         - 使用 opacity 即触发重绘、又触发重排
         - opacity 配合图层使用，不会出发重绘也不触发重排
       - 将多次改变样式的操作合并一次 -不要一条条第修改 DOM 的样式，预先定义好 class 然后修改 DOM 中的 className
       - 利用文档碎片 ducumentFragment
       - 不要把获取某些 DOM 节点的属性值放在一个循环里面当成循环的变量 -但获取文旦的 width，height 的嘿嘿会出发重绘和重排
       - 为动画元素新建图层

# 缓冲

## CDN

1. CDN 的主要目是在提高数据传输速度和稳定性，使内容传输的更快、更稳定，通过在网络各处放置节点服务器所构成的在仙游的互联网基础之上的一层智能虚拟网络。
   能够实时地更具网络流量和个节点的连接，负载情况以及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

2. 基础架构：最简单的 CDN 网络有一个 DNS 服务器和几台缓存服务器组成。
   - 用户输入 URL,会经过 DNS 解析，解析成 Ip,从而找到 CDN 专用服务器。
   - CDN 拿到用户的 IP 地址，随后和区域负载负载均衡设备配合，选择一台用户所述区域的负载均衡设备

## 浏览器多页面之间的通信

浏览器多页应用之间的通信，主要利用浏览器数据存储和服务器两种方式，浏览器数据存储的方式主要使用本地存储方式解决。即调用 localStorage,Cookie 等本地存储方式。
服务器方式主要使用 websocket

- 浏览器存储
  -cookie、SessionStorage、LocalStorage 这三者都可以用来在浏览器端存储数据，而且都是字符串类型的键值对 - session 和 sessionStorage 不是一个概念。服务端有一种存储方式叫：session 会话存储，简称 session.
  Web Storage
- sessionStorage 和 LocalStorage 都是浏览器本地存储，同城 web storage,存储北荣大小一般为 5·10MB
  - localStorage.setItem('key', 'value')
  - localStorage.getItem('key')
  - localStorage.removeItem('key')
  - localStorage.clear()
- Cookie
  Cookie 大小仅为 4KB,主要用途保存登录信息 生命周期 一般由服务器生成,可设置失效时间，在浏览器端生成 cookie,默认关系浏览器后失效。在与服务器端通信，每次都会携带在 HTTP 头中，如果使用 cookie 保存数据太多会有性能问题。
- localStorage
  是 HTML5 标准中新加入的技术，特点：除非被清楚，否则永久保存。一般大小在%MB。
- seesionStorage
  seesionStorage 是 HTML5 新增的一个会话存储对象，用于临时保存同一个窗口的数据，刷新页面数据依旧存在，在关闭窗口将会删除这些数据。
- websocket
  目的在浏览器和服务器之间建议一个不受限的双向通信的通道，为何 http 协议不能做到跟 websocket 一样的功能呢，因为 http 协议是一个请求-响应协议，请求必须有浏览器发送给服务器，服务器才能响应，
  服务器不能主动的给浏览器发数据。而建立 websocket 之后，服务器可以主动发数据给浏览器，浏览器也可以主动发数据给服务器。
  - websocket 的一些事件和方法。例子 node.js 与 websocket - cnpm init -y cnpm i nodejs-websocket -s 建立一个服务端接口 #缓冲

# 缓存

浏览器从硬盘或者内存上将用户之前请求的数据存储起来，当用户在此请求该数据时，不用发送 http 请求，直接 convert 乱来求你本地获取。

## 强缓存

- 不会向服务器发送请求，直接从本地存储中获取数据
- 请求支援的状态码为 200 ok
- 了解相关参数

## 协商缓存

- 向服务器发送清酒，服务器会更具请求头的表示判断是否为协商缓存
- 如果是，就会发送 304 状态码通知浏览器从缓存中读取资源

# http 发展过程

- http/0.9 只有传输 html 文件 传输的数据比较简单 只有请求行 没有请求头和响应头
- http/1.0 解决多种类型文件下载 引入了请求头和响应头进行协商、Cache，状态码，用户代理
  - 队头阻塞的问题
- http/1.1 人们对传输速度的要求 持久化连接来提高连接效率
- http 2.0
  - 浏览器为每个域名最多同时维护 6 个 TCP 连接
  - 使用 CDN 实现域名分片机制
  - 核心：多路复用机制
  - 为解决 xss 攻击，乱来求你引入内容安全策略 CSP，CSP 的核心思路就是让服务器来决定浏览器能够加载那些资源，让服务器决定浏览器是否能够执行内联 Javascript 代码。通过这些手段就可以较少 XSS 攻击。
- 跨域资源共享
  为了解决跨域资源不能互相访问的问题，引入了跨域资源共享 CORS,使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

# 恶意脚本是怎么注入的

- 常见的恶意脚本注入有一下几种，存储型 XSS 攻击（服务器对关键字过滤不严格，将），反射型 XSS 攻击、基于 DOM 的 XSS 攻击。
  - 存储型 XSS 攻击例如
    - 服务器对关键字过滤不严格，将恶意的 js 代码提到服务器端
    - 用户请求时就网页时就获取的含有恶意代码的网页
    - 黑客就获取到当前的 cookie 信息并发送给黑客服务器
    - 这样一来就可以利用用户的 cookie 信息进行登录
  - 放射型 XSS 攻击
    - 恶意代码的请求提交给 Web 服务器，Web 服务器接受到请求时，又将恶意代码反射给浏览器，典型的例子就是点击链接，因为 web 服务器不是存储反射型 xss 攻击的恶意脚本
  - Dom 的 XSS 攻击
    - Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。wifi 路由劫持 本地恶意软件劫持
- 如何阻止 xss 攻击
  存储型和反射型的 xss 攻击都需要经过 Web 服务器来处理，这两个漏洞是服务端的安全漏洞
  - 有效的防止 就需要防止输入，控制输出
    - 服务端对输入的脚本进行过滤和转码
    - 充分利用 CSP
      - 限制加载其他域下的资源文件
      - 禁止向第三方提交数据
      - 禁止执行内联脚本和未授权的脚本
      - 提供了上报机制
  - 使用 httpOnly 属性
    - 很多 XSS 攻击都是用来盗用 Cookie 的，因此可以通过使用 httpOnly 属性来保护我们的 Cookie 的安全，使得我们的 cookie 不能被客户端所读取
- CSRF 攻击
  简称 cross-site request forgery 跨站请求伪造；简单来说即盗用你的身份，以你的名义去请求资源。
  发起该攻击需要三个必要条件
  - 目标站点有漏洞
  - 用户访问过目标站点 并且保持登录状态
  - 需要打开第三方站点，可以是黑客网址，也可以使一些论坛。
    如何防止 CSRF 攻击呢
  - SameSite 属性可以有效降低 CSRF 攻击的风险。
  - 验证请求的来源站点
  - CSRF Token
